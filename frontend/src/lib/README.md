# Frontend Library Structure

This directory contains the refactored frontend code following Svelte 5 best practices and SOLID principles.

## Folder Structure

### `/components`
Reusable UI components that are presentation-focused and stateless.
- **ui/**: Third-party UI library components (stubs for shadcn-svelte-like components)
  - alert-dialog, button, dropdown-menu, input, label, menubar, select, table

### `/features`
Feature-specific components that compose UI components and connect to stores/services.
- `AddModDialog.svelte` - Dialog for searching and adding mods
- `Menu.svelte` - Main application menu bar
- `ModsTable.svelte` - Table displaying project mods
- `NewProjectDialog.svelte` - Dialog for creating new projects

### `/stores`
State management using Svelte 5 runes (`$state`, `$derived`, `$effect`).
- `mods.svelte.ts` - Mod search state management
- `project.svelte.ts` - Project state management  
- `ui.svelte.ts` - UI dialog state management
- `index.ts` - Re-exports for cleaner imports

### `/services`
Business logic and API/backend interaction layer.
- `mod-service.ts` - Mod-related operations (search, add, side determination)
- `project-service.ts` - Project-related operations (open, create, initialize)
- `index.ts` - Re-exports for cleaner imports

### `/types`
TypeScript type definitions.
- `mod.ts` - Mod-related types
- `project.svelte.ts` - Project-related types
- `index.ts` - Re-exports for cleaner imports

### `/utils`
Pure utility functions (cn for class merging, etc.)

### `/icons`
Custom icon components

## Design Principles

### 1. Svelte 5 Runes
- Uses `$state` for reactive state
- Uses `$derived` for computed values
- Uses `$effect` for side effects
- No legacy Svelte stores (writable, readable, derived)

### 2. Separation of Concerns
- **Components**: UI rendering only, no business logic
- **Stores**: State management, expose getters/setters
- **Services**: API calls, business logic, data transformation
- **Types**: TypeScript interfaces and types

### 3. No Prop Drilling
- All shared state lives in stores
- Components access stores directly
- Promotes loose coupling

### 4. Single Responsibility
- Each file has one clear purpose
- Functions are small and focused
- Components are composable

### 5. Type Safety
- Strict TypeScript throughout
- Proper type definitions for all interfaces
- No `any` types in application code

## Usage Examples

### Accessing State
```typescript
import { projectState } from '$lib/stores';

// In component
const hasProject = projectState.hasProject;
const mods = projectState.current.mods;
```

### Calling Services
```typescript
import { modService } from '$lib/services';

await modService.searchMods('jei', 'modrinth');
```

### Using Types
```typescript
import type { Mod, ModSide } from '$lib/types';

const mod: Mod = { ... };
```

## Notes

- Wails bindings (`wailsjs/go`) are generated at build time and should not be committed
- UI components are minimal stubs - replace with actual shadcn-svelte when available
- Runtime errors in `wailsjs/runtime` are expected as those files are generated by Wails
